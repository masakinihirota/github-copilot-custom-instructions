# 使い方

* このREADME.mdおよびsettings.json	以外のファイルを、GitHub Copilotを使用するプロジェクトのフォルダにコピーしてください。
* settings.jsonはVSCodeの設定に挿入します。

## repomix

リポジトリのファイルを1つにするツール
GitHub Copilotやその他LLMに渡すときに便利です。

リポジトリの直下で `npx repomix` を叩くと repomix-output.txt というファイルが出来上がります。
repomixは実装終了ごとに更新するよう自動化するか、手動でrepomixを更新します。

## 指示書（プロンプト）とメタプロンプト

* 指示書（プロンプト）:

GitHub Copilot（または他の大規模言語モデル）に対して、特定のタスクを実行させるための命令や質問。
例：「特定の機能のコードを生成してください」「このコードを修正してください」など。

* メタプロンプト:

プロンプト自体を生成したり、プロンプトの形式や内容を制御したりするためのプロンプト。
「AIにどのように指示すべきか」を指示するためのプロンプト。
例：「あなたは経験豊富なプログラマーです。与えられた仕様に基づいて、Pythonの関数を生成してください。指示書は箇条書きで記述し、具体的な例を含めてください。」

戦略として、GitHub Copilotに渡すプロンプトを作るために、メタプロンプトに詳細な指示を書きます。

## メタプロンプトの詳細な指示の例

以下に、メタプロンプトに詳細な指示を書く例をいくつか示します。

* 役割の定義:
    * 「あなたは、経験豊富なTypeScriptプログラマーです。与えられた仕様に基づいて、効率的で読みやすいTypeScriptコードを生成してください。」
* 出力形式の指定:
    * 「生成するコードには、適切なコメントとドキュメンテーションを含めてください。関数やクラスには、その目的と使い方を説明するdocstringを記述してください。」
    * 「コードはコーディング規約に従ってください。」
* 制約条件の指定:
    * 「生成するコードは、指定されたライブラリのみを使用してください。外部ライブラリを使用する場合は、事前に承認を得てください。」
    * 「コードの実行速度は、〇〇ミリ秒以内に収まるようにしてください。」
* テストコードの生成:
    * 「生成するコードには、単体テストコードを自動的に生成してください。テストコードは、pytestフレームワークを使用してください。」
* .github/copilot-instructions.mdの活用:
    * プロジェクト全体で適応させたいルールは、こちらに記述します。
    * 「このリポジトリで生成されるコードは、常に〇〇のコーディング標準に従ってください。」
    * 「セキュリティ上の脆弱性を避けるため、〇〇のライブラリの使用は避けてください。」

## プロンプトファイルの活用

* 目的や機能ごとにプロンプトファイルを作成し、GitHub Copilotに読み込ませることで、より柔軟なコーディングが可能になります。

メタプロンプトに詳細な指示を書くことで、GitHub Copilotの能力を最大限に引き出し、より効率的かつ高品質なコーディングを実現できます。



## メモリーバンク

メモリーバンクを使う運用をしたい場合Clineを使ったほうがいいです。
GitHub Copilot Agent modeには、Clineのような自動承認モードがないため、メモリーバンクのような機能を使用する場合も、ファイルの読み書き、安全なコマンドの実行、ブラウザの使用、MCPサーバーの使用などの許可を、ユーザー自身が指示し承認する必要があります。
このリポジトリで提供するGitHub Copilot用のメモリーバンクは、自然言語による指示を通じて、ソフトウェア的に関連するファイルを考慮するように設計されています。
便利さを取るか、安全を取るかの判断です。

# GitHub Copilot Agent mode、Cline、Cursor、Windsurf

中・大規模プロジェクトでは、関連性の低いファイルまで考慮してしまうGitHub Copilot Agent modeに対し、Clineは物理的に関連するソースコードのみを読み込むように設計されてます。
また、ClineはAST（抽象構文木）を使用することで、コードの文法的な構造を容易に理解し、プログラムで処理できます。
さらに、Clineは必要最小限の情報のみを逐次取得するアーキテクチャを採用しています。

これらのツールの間には、プロジェクトの規模が大きくなるほど顕著な差が現れます。

repomix、uithub等のツールを使うと利便性が向上します。

AIエディタであるCursorやWindsurfは、継続的にコード全体を認識し、インデックス化します。

## 各ツールの違い

AIが読み込む情報に対して

* 全体をインデックス化するツール: Cursor、Windsurf
* 必要なソースコードをASTで解析するツール: Cline
* ソースコード全体に自然言語で指示するツール: GitHub Copilot Agent mode

いずれのツールを使用するにしても、現在のAIの能力では、詳細な設計を行い、タスクを小さな単位に分割し、それらをAIに読み込ませて、コンポーネント単位でコードを作成していくのが最適解です。

# 用語集

* AST（抽象構文木）: コードの文法的な構造を木構造で表現したもの。プログラムがコードを理解し、処理するために使用されます。
* 計画的かつ反復的な開発プロセス: 事前に計画を立て、小さなサイクルを繰り返しながら開発を進めるアプローチ。アジャイル開発などが該当します。
* 設計書: Webアプリケーションの全体像や各機能の詳細を記述したドキュメント。要件定義、画面設計、データベース設計などが含まれます。
* タスク分解: 設計書に基づいて、開発に必要な作業をより小さな単位に分割すること。
* タスクリストファイル (task-list.md): 分解されたタスクの一覧を記録したファイル。各タスクの進捗状況などを管理します。
* 全体の指示書 (copilot-instructions.md): プロジェクト全体に共通するルール、技術スタック、アーキテクチャなどを定義するファイル。
* 個別の指示書: 特定の作業フェーズ（コード生成、コミットメッセージ、レビュー、テストなど）に関する詳細なルールを定めるファイル。
* プロンプトファイル: 1つのタスク（1機能）の実装に関する具体的な詳細情報を記述したファイル。
* メモリーバンク: GitHub Copilotがセッション間でプロジェクトのコンテキストを維持するための仕組み。複数のマークダウンファイルでプロジェクト情報を記録し、AIが参照できるようにします。
* 技術スタック: プロジェクトで使用する技術の組み合わせ（プログラミング言語、フレームワーク、ライブラリなど）。
* コーディング規約: プロジェクト全体で一貫したコード品質を保つためのルール（命名規則、コメントの書き方、推奨されるプログラミングパターンなど）。
* コロケーション: 関連するファイルを近くに配置する開発手法。ここでは、コンポーネントのテストコードを同じフォルダに配置することを指します。
* ユニットテスト: 個々のコンポーネントや関数が意図した通りに動作するかを検証するテスト。
* 統合テスト: 複数のコンポーネントやシステムが連携して正しく動作するかを検証するテスト。
* 技術的負債: 将来的に追加の作業が必要になる、現在の不完全な設計や実装。コードの重複、複雑すぎるコードなどが該当します。
* コードレビュー: 他の開発者が作成したコードをチェックし、品質や潜在的な問題を評価するプロセス。
* MCP (Model Context Protocol): GitHub Copilot Agent modeで外部サービスと連携するための設定プロトコル。
* GitHub Copilot Agent mode: GitHub Copilotの機能の一つで、外部ツールやサービスと連携してより高度な支援を行うモード。

# 参考資料

* Cline / Roo-Codeにおけるコード理解と新規・保守タスクの現状: [https://zenn.dev/tesla/articles/33d196d17bf3bb](https://zenn.dev/tesla/articles/33d196d17bf3bb)

